# JavaScript

## 클로저는 무엇이며, 어떻게/왜 사용하나요?

- 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. "렉시컬"은 렉시컬 범위 지정이 변수가 사용 가능한 위치를 결정하기 위해 소스 코드 내에서 변수가 선언된 위치를 사용한다는 사실을 나타냅니다. 클로저는 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.

- 외부함수의 변수에 접근할 수 있는 내부 함수

- 일반적으로 함수를 return 하여 사용

- return하는 내부 함수를 closure 함수라고 말함

- closure가 가지는 3가지 scope chain
  1. closure 자신에 대한 접근(closure function 내에 정의된 변수)
  2. 외부 함수의 변수에 대한 접근
  3. 전역 변수에 대한 접근

* 왜 클로저를 사용합니까?
  - 클로저로 데이터 프라이버시(외부에서 접근할 수 없도록)) / private method를 모방. 일반적으로 모듈 패턴에 사용됩니다.
  - 부분 적용 또는 currying.

- 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다. 함수 객체의 내부 슬롯 [[Environment]] 에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.

- 실행 컨택스트에서 렉시컬 환경안에 OuterLexicalEnvironmentReference 라는 곳에 위에서 말한 내부슬롯 [[Environment]] 와 같은 값이 저장되어 있다 그래서 상위함수가 생명을 다해도 내부함수가 상위함수를 참조하고 있기 때문에 실행 컨택스트스택에서만 사라지고 렉시컬 환경, 환경레코드 등이 살아있어서 상위함수의 값을 참조할 수 있게 된다(가비지 컬렉터에 의해 제거되지 않는다).

![참고](https://i.postimg.cc/g0bH3h8H/Closure5.png)

---

<br>

## 호이스팅이란?

런타임 이전에 자바스크립트 엔진이 가장 먼저 var, let const, 함수 선언식 등으로 선언한 변수들을 찾아서 가장 위쪽에서 선언 한 것처럼 끌어올린다.

var 그리고 let, const 는 다르게 작동한다. 먼저 var은 실행 컨텍스트에서 객체 환경 레코드로 들어가고 이것은 window객체(브라우저에서)의 속성으로 들어가게 된다. window는 스코프 체인의 상단에 위치하고 있으므로 어디서든 접근할 수 있게 된다 var는 선언과 초기화 단계가 한번에 이루어 지기 때문에 에러가 나지 않고 할당문 보다 빨리 사용했을때 undefined를 반환한다.

![참고](https://i.postimg.cc/wTb9d8nM/execution-context13.png)

let과 const로 선언한 변수는 객체 환경 레코드가 아닌 선언적 환경 레코드로 들어가게 되고 이것은 window 속성으로 들어가지 않는다. let과 const는 호이스팅은 되지만 실제 코드로 작성한 let과 const를 만나기 전까지 선언단계만 이루어지고 초기화 단계는 이루어 지지 않기 때문에 에러가 발생하게 된다 선언단계와 초기화 단계 사이를 TDZ 일시적 사각지대라고 부른다.

![참고](https://i.postimg.cc/8CFhpSyC/execution-context15.png)

## 브라우저 동작 원리

①②③④ 주소창에 www.google.com을 치게되면 도메인네임(google.com)을 DNS(도메인 네임과 함께 해당하는 IP(ex. 127.0.0.1 ) 주소값을 한 쌍으로 저장하고 있는 데이터베이스)서버에서 해당 도메인 네임에 해당하는 IP 주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.

⑤⑥ 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성함. 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송됨.

⑦ 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환됨.
⑧ 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색함.

⑨⑩ 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성함. 이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송됨.

⑪⑫ 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환됨. 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨.

![참고](https://t1.daumcdn.net/cfile/tistory/99F099375C124B2D02)

> 출처: http://tcpschool.com/webbasic/works

서버의 기본설정(보통 index.html)을 서버로 부터 받게되면 HTML과 CSS를 파싱합니다(파싱은 일련의 문자열을 의미있는 token(어휘 분석의 단위) 으로 분해하고 그것들로 이루어진 tree 를 만드는 과정).

이 과정으로 DOM tree, CSSOM tree를 생성하고 이것들을 결합하여 Render Tree를 생성한다. 이렇게 생성된 Render Tree를 기반으로 브라우저는 웹 페이지를 표시한다.

자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 일시 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.

제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 렌더링 엔진이 HTML과 CSS를 파싱하여 DOM tree와 CSSOM tree를 생성하듯이 자바스크립트 엔진은 자바스크립트를 파싱하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성한다.
