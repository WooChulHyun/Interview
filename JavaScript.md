# JavaScript

## 클로저는 무엇이며, 어떻게/왜 사용하나요?

- 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. "렉시컬"은 렉시컬 범위 지정이 변수가 사용 가능한 위치를 결정하기 위해 소스 코드 내에서 변수가 선언된 위치를 사용한다는 사실을 나타냅니다. 클로저는 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.

- 외부함수의 변수에 접근할 수 있는 내부 함수

- 일반적으로 함수를 return 하여 사용

- return하는 내부 함수를 closure 함수라고 말함

- closure가 가지는 3가지 scope chain
  1. closure 자신에 대한 접근(closure function 내에 정의된 변수)
  2. 외부 함수의 변수에 대한 접근
  3. 전역 변수에 대한 접근

* 왜 클로저를 사용합니까?
  - 클로저로 데이터 프라이버시(외부에서 접근할 수 없도록)) / private method를 모방. 일반적으로 모듈 패턴에 사용됩니다.
  - 부분 적용 또는 currying.

- 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다. 함수 객체의 내부 슬롯 [[Environment]] 에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이다. 함수 객체는 내부 슬롯 [[Environment]]에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.

- 실행 컨택스트에서 렉시컬 환경안에 OuterLexicalEnvironmentReference 라는 곳에 위에서 말한 내부슬롯 [[Environment]] 와 같은 값이 저장되어 있다 그래서 상위함수가 생명을 다해도 내부함수가 상위함수를 참조하고 있기 때문에 실행 컨택스트스택에서만 사라지고 렉시컬 환경, 환경레코드 등이 살아있어서 상위함수의 값을 참조할 수 있게 된다(가비지 컬렉터에 의해 제거되지 않는다).

![참고](https://i.postimg.cc/g0bH3h8H/Closure5.png)

---

<br>

## 호이스팅이란?

런타임 이전에 자바스크립트 엔진이 가장 먼저 var, let const, 함수 선언식 등으로 선언한 변수들을 찾아서 가장 위쪽에서 선언 한 것처럼 끌어올린다.

var 그리고 let, const 는 다르게 작동한다. 먼저 var은 실행 컨텍스트에서 객체 환경 레코드로 들어가고 이것은 window객체(브라우저에서)의 속성으로 들어가게 된다. window는 스코프 체인의 상단에 위치하고 있으므로 어디서든 접근할 수 있게 된다 var는 선언과 초기화 단계가 한번에 이루어 지기 때문에 에러가 나지 않고 할당문 보다 빨리 사용했을때 undefined를 반환한다.

![참고](https://i.postimg.cc/wTb9d8nM/execution-context13.png)

let과 const로 선언한 변수는 객체 환경 레코드가 아닌 선언적 환경 레코드로 들어가게 되고 이것은 window 속성으로 들어가지 않는다. let과 const는 호이스팅은 되지만 실제 코드로 작성한 let과 const를 만나기 전까지 선언단계만 이루어지고 초기화 단계는 이루어 지지 않기 때문에 에러가 발생하게 된다 선언단계와 초기화 단계 사이를 TDZ 일시적 사각지대라고 부른다.

![참고](https://i.postimg.cc/8CFhpSyC/execution-context15.png)
